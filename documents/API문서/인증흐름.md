## 전체 인증 흐름
### 1단계: 클라이언트가 API 요청 전
```
클라이언트 → GET /api/profile/me
Headers:
  Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 2단계: Spring Security 필터 체인 시작
요청이 서버에 도착하면 Spring Security의 필터 체인이 실행됩니다. SecurityConfig에서 설정한 필터 순서대로 실행됩니다:
``` java 
 // SecurityConfig.java
 http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
 ```
 JwtAuthenticationFilter가 UsernamePasswordAuthenticationFilter보다 먼저 실행됩니다.

### 3단계: JwtAuthenticationFilter 실행
JwtAuthenticationFilter.doFilterInternal()이 실행됩니다:
``` java 
// JwtAuthenticationFilter.java
 @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain
    ) throws ServletException, IOException {
        
        // 1. Authorization 헤더에서 토큰 추출
        String token = resolveToken(request);
        
        // 2. 토큰이 있고 유효한 경우에만 인증 처리
        if (StringUtils.hasText(token) && jwtTokenProvider.validateToken(token)) {
            // 3. 블랙리스트 토큰 검증
            if (!tokenBlacklistRepository.existsByToken(token)) {
                // 4. 토큰에서 인증 정보 추출
                Authentication authentication = jwtTokenProvider.getAuthentication(token);
                
                // 5. SecurityContextHolder에 인증 정보 저장
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        
        // 6. 다음 필터로 요청 전달
        filterChain.doFilter(request, response);
    }
```
동작:
- resolveToken(): Authorization: Bearer <TOKEN>에서 토큰 추출
- jwtTokenProvider.validateToken(): 토큰 유효성 검증
- 블랙리스트 확인: 로그아웃된 토큰인지 확인
- jwtTokenProvider.getAuthentication(): 토큰에서 Authentication 객체 생성

### 4단계: JwtTokenProvider.getAuthentication() 실행
``` java
  // JwtTokenProvider.java
  public Authentication getAuthentication(String token) {
        Claims claims = getClaims(token);
        String email = claims.getSubject();
        String role = claims.get("role", String.class);
        
        List<SimpleGrantedAuthority> authorities = List.of(
                new SimpleGrantedAuthority("ROLE_" + role)
        );
        
        return new UsernamePasswordAuthenticationToken(
                email,
                null,
                authorities
        );
    }
```
이 메서드는:
- JWT 토큰을 파싱하여 Claims 추출
- subject에서 email 추출
- role claim에서 권한 추출
- UsernamePasswordAuthenticationToken 생성
  - principal: email (String)
  - credentials: null
  - authorities: [ROLE_USER] 또는 [ROLE_ADMIN]

### 5단계: SecurityContextHolder에 저장
``` java 
 // JwtAuthenticationFilter.java
       SecurityContextHolder.getContext().setAuthentication(authentication);
```
SecurityContextHolder는 ThreadLocal을 사용합니다:
- 각 요청(스레드)마다 독립적인 SecurityContext 보관
- 현재 스레드에서만 접근 가능
- 요청 종료 시 자동 정리

### 6단계: 필터 체인 계속 진행
``` java 
 // JwtAuthenticationFilter.java
 filterChain.doFilter(request, response);
```
다음 필터로 요청을 전달합니다. 이후:
- @PreAuthorize("isAuthenticated()") 검사
- 컨트롤러 메서드 실행

### 7단계: 컨트롤러에서 SecurityUtils 호출
컨트롤러에서 SecurityUtils.getCurrentAuthentication()을 호출하면:
``` java
    // SecirotyUtils.java
    public static Authentication getCurrentAuthentication() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new IllegalStateException("인증되지 않은 사용자입니다.");
        }
        
        return authentication;
    }
```
동작:
- SecurityContextHolder.getContext(): 현재 스레드의 SecurityContext 조회
- .getAuthentication(): 3단계에서 저장한 Authentication 객체 반환
- null 또는 미인증이면 예외 발생
- 정상이면 Authentication 반환

### 핵심 개념: ThreadLocal
SecurityContextHolder는 ThreadLocal을 사용합니다:
``` java
// 내부적으로 이런 식으로 동작합니다
ThreadLocal<SecurityContext> contextHolder = new ThreadLocal<>();

// 필터에서 저장
contextHolder.set(securityContext);  // 현재 스레드에만 저장

// 컨트롤러에서 조회
SecurityContext context = contextHolder.get();  // 같은 스레드에서만 조회 가능
```
장점:
- 각 요청(스레드)이 독립적인 SecurityContext를 가짐
- 스레드 간 간섭 없음
- 요청 종료 시 자동 정리

### 전체 흐름 다이어그램
```
[클라이언트]
    ↓ HTTP Request + Authorization Header
[서버]
    ↓
[Spring Security Filter Chain]
    ↓
[JwtAuthenticationFilter]
    ├─ 토큰 추출
    ├─ 토큰 검증
    ├─ Authentication 객체 생성
    └─ SecurityContextHolder에 저장 ← 핵심!
    ↓
[다른 필터들]
    ↓
[@PreAuthorize 검사]
    ↓
[컨트롤러]
    ↓
[SecurityUtils.getCurrentAuthentication()]
    └─ SecurityContextHolder에서 조회 ← 여기서 가져옴!
    ↓
[비즈니스 로직 실행]
```

### 요약
- 필터에서 토큰 검증 후 SecurityContextHolder에 Authentication 저장
- SecurityContextHolder는 ThreadLocal로 스레드별로 관리
- 컨트롤러에서 SecurityUtils.getCurrentAuthentication()으로 같은 스레드의 Authentication 조회
- 요청 종료 시 ThreadLocal 자동 정리
- 이 방식으로 매 요청마다 인증 정보를 다시 확인하지 않고, 필터에서 한 번 설정한 값을 컨트롤러에서 재사용할 수 있습니다.